---
layout: post
title: Git基础
subtitle: git简介及基本操作
date: 2017-02-04
author: Cong Bao
header-img: "img/post-bg-01.jpg"
---

## GIT简介

Git是当年Linus Torvalds（Linux之父）为了方便管理Linux内核开发而开发的版本控制工具。发展到现在，git已经成为许多大中小项目首选的版本控制系统。帮助项目敏捷、高效地进行。

那么问题来了，我们为什么要进行版本控制？或许你在学校的时候，写过一些小程序，做过一些小项目。但每次都是打开IDE，编写代码，修改bug，最后实现了所有功能并确保没有错误后提交，就结束了。对于小的项目来说，这或许没有问题；但项目体积一旦膨胀，就会存在很多隐患。比如某一部分功能不再需要了，不巧系统耦合度又很高，那你只能一处一处地去寻找，把代码慢慢删掉（但这一般是系统架构缺陷）；又或者是因为一些操作错误，不小心丢失了工程代码，这时内心肯定是绝望的（不要问我为什么知道）。而版本控制在这时就是一瓶后悔药，可以让你回到你想要去的状态点，然后重新来过。当然这只是版本控制的一个作用。版本控制会记录每一次修改操作，不管是增还是删还是改，一旦将来需要检查修改记录或者回溯，就极为方便且安全。

当然版本控制也有其方法。最最傻的办法就是实现完一个功能后，把所有工程内容都拷贝一份进行备份，标记上版本号，然后继续开发。这样固然简单，但却没有详细的修改记录，使得将来很难检查和恢复。于是就出现了像RCS（Revision  Control System）这样的通过文件补丁来记录修订前后内容变化的系统。但这种方法主要是针对于本地系统的，而项目的开发往往有许多开发者的参与，这时就需要一个系统来管理不同开发者的协作。集中式版本控制系统（Centralized Version Control System）就出现了。在这种系统下，所有开发者都通过客户端连接到一个服务器上，根据需求从服务器上取出最新的文件或者提交修改。但这就像所有鸡蛋都在一个篮子里，一旦服务器故障，不但开发者没法提交更新，还会面临数据丢失的风险。再然后，分布式版本控制系统（Distributed Version Control System）就出现了，我们的git就是其中的一员。在这种系统下，客户端不再向单一的服务器提取数据，而是直接把整个原始代码仓库拷贝下来，在本地提交，最后在需要的时候再向服务器提交。这样开发者不仅可以本地工作，而且每一个客户端都持有了对原始代码库的备份，大大降低了代码丢失的风险。

## GIT基本工作流程

这一节将会介绍一些基本的git工作流程。安装与配置请参照[git官方文档](https://git-scm.com/doc)。上面也有很多简介和教程。看官方文档比看博客有价值多了。

具体的操作都以Linux系统环境为例。

### 1. 初始化本地仓库

想要用git进行版本控制，首先就要初始化一个git本地仓库。一般来说，这个本地仓库就是你的项目根目录。用cd命令来到你的目录下后，输入：

	$ git init

本地仓库就完成初始化了。此时git会新建一个.git文件夹，用以存放所有资源。当然这个文件夹是隐藏的（在Linux下，所有以（.）为开头命名的文件和文件夹都默认是隐藏的），你可能不会马上注意到它的出现，但只有这个文件夹被建立了，你才可以进行接下来的一系列操作。当然如果你将这个文件夹删除，git本地仓库就失效了，如果没有和远程仓库进行同步，所有修改记录都将消失。

### 2.检查更新

完成初始化后，你就可以尽情地写代码了。当你完成一部分工作后，准备提交前，可以先检查一下你的工作目录发生的变化，只需要输入：

	$ git status

就会返回目录下所有文件的变化。如果没有任何修改，你很可能会看到这样的结果：

	$ git status
	On branch master
	Your branch is up-to-date with 'origin/master'.
	nothing to commit, working directory clean

但如果文件有所改动，比如加入一个README文件，就会返回这样的结果：

	$ git status
	On branch master
	Your branch is up-to-date with 'origin/master'.
	Untracked files:
	  (use "git add <file>..." to include in what will be committed)

	    README

	nothing added to commit but untracked files present (use "git add" to track)

你会发现README被归类为untracked文件，这里的意思是git发现README这个文件在以前的提交版本中没有出现过，但git也不会帮你自动追踪修改过的文件，这需要你手动操作。

### 3. 追踪更新

这时我们输入：

	$ git add README

我们新添加的README文件就会被追踪。README的状态也转变为tracked。如果这时我们再用`git status`命令的话，就会显示这样的结果：

	$ git status
	On branch master
	Your branch is up-to-date with 'origin/master'.
	Changes to be committed:
	  (use "git reset HEAD <file>..." to unstage)

	    new file:   README

可见我们新添加的文件已经准备就绪，可以被提交了。如果你有多个文件，也可以使用`git add *.*`这样的通配符来匹配文件，或者干脆使用`git add -A`来追踪所有更改。虽然命令里有add，但并不意味着是添加一个新出现的文件，而是添加一个新的追踪记录，所以不管是增还是删还是改，都要用`git add`命令来进行追踪。

### 4. 提交更新

当完成步骤3后，如果你确定没有其他更改的话，就可以进行提交了。提交的命令很简单，这样输入就行：

	$ git commit -m "add README"

其中-m选项是给本次提交附上一条信息进行说明，这个步骤是必须的，如果不添加，git也会打开编辑器让你输入一条信息。此时你会见到类似这样的信息：

	$ git commit -m "add README"
	[master cd3d18c] add README
	 1 file changed, 1 insertions(+), 0 deletions(-)

当然，如果你想偷懒的话，可以把步骤3和步骤4合并起来，只需要输入`git commit -a -m "..."`命令就行了。Git有很多可以合并的命令，但如果你不确定的话，还是一步步输入比较稳妥。偷懒很容易出错。

### 5. 同步远程仓库

当你提交完更新后，就要将新版本的代码同步到远程仓库，这样一个基本的git工作流程就结束了。

首先，如果你还没有连接远程仓库的话，你得先添加你的远程仓库，输入：

	$ git remote add origin [Your Remote URL]

这里的URL，如果是GitHub的话，就类似于https://github.com/[username]/[repository]的形式。或是git@github.com:[username]/[repository].git

添加完成后，可以通过`git remote -v`来查看。 

此时，一切准备就绪后，就可以和远程仓库进行同步了，只需输入：

	$ git push origin master

就可以将提交的更新同步到远程仓库的主分支上了。

##GIT常用功能及指令

在上一节中介绍的是一个版本控制工作流程中必不可少的步骤和指令。这一节将简单介绍一些比较常见的，虽然不是必要的但很有用的功能。

### 1. 分支管理

Git的分支管理是一个大学问，如果要详细描述的话完全可以再写一篇长文。但这里只做一些简单的介绍，详细内容还请参考[官方文档](https://git-scm.com/doc)。

+ 分支的创建和切换

当你创建git仓库的时候，git就已经帮你建立了一条默认的分支：master。在上一节中，我们的操作基本都是在master分支上进行的。但这并不是一个良好的习惯。一般来说，每当我们要增加一个新功能，或者修复一个在之前提交版本上出现的bug，我们就要新建一条分支。在完成工作后，提交修改，然后合并到主分支，最后把这些新建的分支删除。这样做能确保项目主进程的正确性和稳定性，还能获得一个清晰的工作流程。

创建一个新的分支很简单，只要输入：

    $ git branch [branch name]

就能创建一个以[branch name]为名字的新分支。接下来我们输入命令来切换到这个新建的分支上：

    $ git checkout [branch name]

以上这两步可以合并为：

    $ git checkout -b [branch name]

即新建一个分支后马上切换到它上面去。还是那句话，如果不清楚命令的含义的话，不要使用合并的命令，一步一步来比较稳妥。

这里稍微提一句，git新建分支并不会创建一个原分支的副本，而是使用指针的方式将每一个分支指向自己最后的提交对象上。当不同的分支同步推进时，就会产生分叉，就像一颗树一样。但不管是那个分支，都可以沿着“树枝”，回溯到以前的提交对象上。这种轻量型的分枝技术使得git的分支很快。而分支的切换是基于一个特殊的HEAD指针的，这个指针将指向你当前使用的分支的指针。

+ 分支的合并

当你在新建的分支里完成所有工作后，就可以将这个分支整合到你的主分支上了（当然也可以是一个上级分支，不一定是主分支）。这里假设你的新分支叫做`dev`，现在要整合到主分支上，那么首先你要先回到`master`分支，然后进行合并：

    $ git checkout master
    $ git merge dev

这里git将会进行一次三方合并计算，在主分支上创建一个新的提交对象，然后主分支的指针移到这个新的提交对象上。当然有时会产生合并冲突的情况，比如你在`master`分支和`dev`分支上修改了同一个对象，就很可能产生冲突。这时git会停下来等待你解决冲突后再提交。一般来说冲突只能人为解决。

+ 分支的衍合

类似于合并，衍合是另一种整合不同分支的方法。我们继续沿用上面的例子，衍合的命令和合并非常相似：

    $ git checkout dev
    $ git rebase master

你可能已经注意到了，我们没有切换到`master`分支上，而是在`dev`分支上对`master`分支进行了衍合。衍合与合并不同的是，git不会对将要整合的分支进行三方合并计算，而是把`dev`分支中产生的提交对象进行计算后，直接作为新的提交对象加入`master`分支中。这样进行整合会有一个很干净的历史记录，不像合并会有很多的分叉，衍合的历史记录看上去就是一条直线。但最后整合得到的结果和合并是没有区别的。

但请注意，在团队协作时，如果你要将分支中的提交对象发布到公共仓库中去的话，最好不要用衍合，而使用合并。衍合很有可能会让其他开发人员混淆。

+ 分支的删除

当新建的分支完成工作并且整合到主分支后，这个分支就不再需要了，我们就可以将它移除。输入：

    $ git branch -d [branch name]

就可以把这条分支删除了。清理分支也是分支管理很重要的一环。

### 2. 检查差异

在提交更新之前，可能你觉得`git status`命令提供的信息太少了，想要再详细检查一下文件具体发生的变化，就可以使用`git diff`命令来查看：

    $ git diff

这将显示工作目录中已经发生修改但还没有被追踪的文件的更新记录。若要查看已经被追踪的文件和上一次提交之间产生的变化，可以这样输入：

    $ git diff --cached

或者

    $ git diff --staged

这两个命令的结果是一样的，只不过后者是Git 1.6.1版本以后才能使用的。

### 3. 移除和移动文件

如果文件还没有被追踪，并且你想移除这个文件，那你只管将其删除就行了，不会对git产生影响，最多只是使用`git status`命令查看时会看到文件存在与不存在的两种情况。但如果文件已经被追踪，这里有两种情况需要考虑：

+ 想要将文件从追踪列表中删除，并且本地文件也一起删除

这种情况下，我们可以使用命令：

    $ git rm -f [file name]

加上-f选项后，不仅文件会从追踪列表中删除，本地文件也会一起删除。

+ 想要将文件从追踪列表中删除，但不希望本地文件也被删除

这时我们可以这样输入：

    $ git rm --cached [file name]

这样这个文件就会从追踪列表中消失，但本地文件还会保留。

移动文件可以使用`git mv`命令完成。这个指令和系统的rm指令很像，你可以将文件移动到其他目录，也可以对文件进行重命名。但前提是这个文件已经被加入追踪列表了。可以这样输入来完成移动：

    $ git mv [from] [to]

文件就会从原来的位置移动到你指定的位置，名字也应你的要求更改。

### 4. 查看提交记录

在进行了一系列更新和提交操作后，你可能想回顾一下之前的操作，这时就可以这样输入：

    $ git log

来获取操作日志。但有趣的是，你可以自己定义日志的显示格式，比如这样输入：

    $ git log --pretty=format:"%h - %an, %at : %s"

下面这张表格列举了常用的占位符和它们的含义。

| --------+------------------------------- |
| 占位符   | 说明                            |
| :-----: | :----------------------------- |
| %H      | 提交对象（commit）的完整哈希字串 |
| %h      | 提交对象的简短哈希字串 |
| %T      | 树对象（tree）的完整哈希字串 |
| %t      | 树对象的简短哈希字串 |
| %P      | 父对象（parent）的完整哈希字串 |
| %p      | 父对象的简短哈希字串 |
| %an     | 作者（author）的名字 |
| %ae     | 作者的电子邮件地址 |
| %ad     | 作者修订日期（可以用 -date= 选项定制格式） |
| %ar     | 作者修订日期，按多久以前的方式显示 |
| %cn     | 提交者(committer)的名字 |
| %ce     | 提交者的电子邮件地址 |
| %cd     | 提交日期 |
| %cr     | 提交日期，按多久以前的方式显示 |
| %s      | 提交说明 |
| --------+------------------------------- |

你甚至还能使用`--graph`选项来查看用简单符号组成的描述分支的图。

### 5. 撤销操作

有的时候难免会有失误，需要撤销或取消之前的一些操作，我们就可以使用这些命令。但请注意，有些操作是没有回头路的，一旦执行，就不能再撤销。

+ 修改最后一次提交

如果你已经提交了更新，却突然发现遗漏了一些文件，或者提交信息写得不对，这时就可以用`--amend`选项来重新提交。比如这样：

    $ git commit -m "first commit"
    $ git add [something forgot]
    $ git commit --amend

就可以把忘记追踪的文件添加进来了。第二次的提交只是第一次提交的重演，不会增加新的提交对象。

+ 取消已经被追踪的文件

如果你突然不希望一个文件被加入追踪列表，但此时追踪指令已经执行了，就可以这样输入：

    $ git reset HEAD [file name]

这样当你使用`git status`命令查看时，就会发现文件又被标记为untracked了。

+ 撤回对文件的修改

首先，这是一个比较危险的操作，因为撤销会使你对文件的修改失效，这很有可能意味着前功尽弃。所以在使用这个功能前，请务必确保真的不再需要修改的内容。

如果一个修改过的文件还没有被追踪，我们就可以这样输入来撤销对它的修改：

    $ git checkout -- [file name]

这样这个文件就会回到修改前的状态了。

请注意，任何已经被git提交的文件都可以恢复，即便是已经删除的分支中的提交或是用`--amend`选项重新进行的提交都可以恢复。但如果一个文件没有被提交过，那对git来说它就像不存在一样，无法进行恢复。

## 小结

到此，git的基本工作流程和一些基本操作就介绍完了。这篇文章只是很概括性地介绍了一些git指令的用法，但其实每一个功能都还能拓展出很多的内容。想要更多的了解，还请参考[官方文档](https://git-scm.com/doc)。