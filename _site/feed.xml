<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>B.C. Personal Studio</title>
    <description>A studio to show my personal projects and experience sharing.</description>
    <link>https://congbao.github.io//</link>
    <atom:link href="https://congbao.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 04 Feb 2017 23:09:26 +0000</pubDate>
    <lastBuildDate>Sat, 04 Feb 2017 23:09:26 +0000</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Git基础</title>
        <description>&lt;h2 id=&quot;git&quot;&gt;GIT简介&lt;/h2&gt;
&lt;p&gt;Git是当年Linus Torvalds（Linux之父）为了方便管理Linux内核开发而开发的版本控制工具。发展到现在，git已经成为许多大中小项目首选的版本控制系统。帮助项目敏捷、高效地进行。&lt;/p&gt;

&lt;p&gt;那么问题来了，我们为什么要进行版本控制？或许你在学校的时候，写过一些小程序，做过一些小项目。但每次都是打开IDE，编写代码，修改bug，最后实现了所有功能并确保没有错误后提交，就结束了。对于小的项目来说，这或许没有问题；但项目体积一旦膨胀，就会存在很多隐患。比如某一部分功能不再需要了，不巧系统耦合度又很高，那你只能一处一处地去寻找，把代码慢慢删掉（但这一般是系统架构缺陷）；又或者是因为一些操作错误，不小心丢失了工程代码，这时内心肯定是绝望的（不要问我为什么知道）。而版本控制在这时就是一瓶后悔药，可以让你回到你想要去的状态点，然后重新来过。当然这只是版本控制的一个作用。版本控制会记录每一次修改操作，不管是增还是删还是改，一旦将来需要检查修改记录或者回溯，就极为方便且安全。&lt;/p&gt;

&lt;p&gt;当然版本控制也有其方法。最最傻的办法就是实现完一个功能后，把所有工程内容都拷贝一份进行备份，标记上版本号，然后继续开发。这样固然简单，但却没有详细的修改记录，使得将来很难检查和恢复。于是就出现了像RCS（Revision  Control System）这样的通过文件补丁来记录修订前后内容变化的系统。但这种方法主要是针对于本地系统的，而项目的开发往往有许多开发者的参与，这时就需要一个系统来管理不同开发者的协作。集中式版本控制系统（Centralized Version Control System）就出现了。在这种系统下，所有开发者都通过客户端连接到一个服务器上，根据需求从服务器上取出最新的文件或者提交修改。但这就像所有鸡蛋都在一个篮子里，一旦服务器故障，不但开发者没法提交更新，还会面临数据丢失的风险。再然后，分布式版本控制系统（Distributed Version Control System）就出现了，我们的git就是其中的一员。在这种系统下，客户端不再向单一的服务器提取数据，而是直接把整个原始代码仓库拷贝下来，在本地提交，最后在需要的时候再向服务器提交。这样开发者不仅可以本地工作，而且每一个客户端都持有了对原始代码库的备份，大大降低了代码丢失的风险。&lt;/p&gt;

&lt;h2 id=&quot;git-1&quot;&gt;GIT基本工作流程&lt;/h2&gt;
&lt;p&gt;这一节将会介绍一些基本的git工作流程。安装与配置请参照&lt;a href=&quot;https://git-scm.com/doc&quot;&gt;git官方文档&lt;/a&gt;。上面也有很多简介和教程。看官方文档比看博客有价值多了。&lt;/p&gt;

&lt;p&gt;具体的操作都以Linux系统环境为例。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;1. 初始化本地仓库&lt;/h3&gt;
&lt;p&gt;想要用git进行版本控制，首先就要初始化一个git本地仓库。一般来说，这个本地仓库就是你的项目根目录。用cd命令来到你的目录下后，输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本地仓库就完成初始化了。此时git会新建一个.git文件夹，用以存放所有资源。当然这个文件夹是隐藏的（在Linux下，所有以（.）为开头命名的文件和文件夹都默认是隐藏的），你可能不会马上注意到它的出现，但只有这个文件夹被建立了，你才可以进行接下来的一系列操作。当然如果你将这个文件夹删除，git本地仓库就失效了，如果没有和远程仓库进行同步，所有修改记录都将消失。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2.检查更新&lt;/h3&gt;
&lt;p&gt;完成初始化后，你就可以尽情地写代码了。当你完成一部分工作后，准备提交前，可以先检查一下你的工作目录发生的变化，只需要输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就会返回目录下所有文件的变化。如果没有任何修改，你很可能会看到这样的结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
nothing to commit, working directory clean
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但如果文件有所改动，比如加入一个README文件，就会返回这样的结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Untracked files:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)

    README

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你会发现README被归类为untracked文件，这里的意思是git发现README这个文件在以前的提交版本中没有出现过，但git也不会帮你自动追踪修改过的文件，这需要你手动操作。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3. 追踪更新&lt;/h3&gt;
&lt;p&gt;这时我们输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add README
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们新添加的README文件就会被追踪。README的状态也转变为tracked。如果这时我们再用&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;命令的话，就会显示这样的结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    new file:   README
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可见我们新添加的文件已经准备就绪，可以被提交了。如果你有多个文件，也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git add *.*&lt;/code&gt;这样的通配符来匹配文件，或者干脆使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git add -A&lt;/code&gt;来追踪所有更改。虽然命令里有add，但并不意味着是添加一个新出现的文件，而是添加一个新的追踪记录，所以不管是增还是删还是改，都要用&lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt;命令来进行追踪。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;4. 提交更新&lt;/h3&gt;
&lt;p&gt;当完成步骤3后，如果你确定没有其他更改的话，就可以进行提交了。提交的命令很简单，这样输入就行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git commit -m &quot;add README&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中-m选项是给本次提交附上一条信息进行说明，这个步骤是必须的，如果不添加，git也会打开编辑器让你输入一条信息。此时你会见到类似这样的信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git commit -m &quot;add README&quot;
[master cd3d18c] add README
 1 file changed, 1 insertions(+), 0 deletions(-)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，如果你想偷懒的话，可以把步骤3和步骤4合并起来，只需要输入&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -a -m &quot;...&quot;&lt;/code&gt;命令就行了。Git有很多可以合并的命令，但如果你不确定的话，还是一步步输入比较稳妥。偷懒很容易出错。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;5. 同步远程仓库&lt;/h3&gt;
&lt;p&gt;当你提交完更新后，就要将新版本的代码同步到远程仓库，这样一个基本的git工作流程就结束了。&lt;/p&gt;

&lt;p&gt;首先，你得先添加你的远程仓库，输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git remote add origin [Your Remote URL]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的URL，如果是GitHub的话，就类似于https://github.com/[username]/[repository]的形式。或是git@github.com:[username]/[repository].git&lt;/p&gt;

&lt;p&gt;添加完成后，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git remote -v&lt;/code&gt;来查看。&lt;/p&gt;

&lt;p&gt;此时，一切准备就绪后，就可以和远程仓库进行同步了，只需输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就可以将提交的更新同步到远程仓库的主分支上了。&lt;/p&gt;

&lt;h2 id=&quot;git-2&quot;&gt;GIT常用功能及指令&lt;/h2&gt;

&lt;p&gt;contd.&lt;/p&gt;
</description>
        <pubDate>Sat, 04 Feb 2017 00:00:00 +0000</pubDate>
        <link>https://congbao.github.io//2017/02/04/git%E5%9F%BA%E7%A1%80/</link>
        <guid isPermaLink="true">https://congbao.github.io//2017/02/04/git%E5%9F%BA%E7%A1%80/</guid>
        
        
      </item>
    
      <item>
        <title>短文</title>
        <description>&lt;p&gt;这是我第一次写博客。&lt;/p&gt;

&lt;p&gt;虽然以前文字写得也不少，但大部分都贡献给了小说和游戏剧本。自从高中毕业开始认真学习技术以后，键盘也没有少敲，但剧情文字就基本变成代码了。&lt;/p&gt;

&lt;p&gt;曾经也想过要写博客，可是看过了很多大神的博客后，感觉自己能写出来的内容，不是人家写过了，就是没有别人来得详细深入，所以也就渐渐放弃了这个想法。直到最近准备开始做学年项目，每天查阅各种资料，学习各种知识，从算法理论，到代码实现，到项目管理，各个层次众多的内容很让人混乱。这时我就想起了博客还有这样一种用法，把自己学习到的知识，积累到的经验整理起来，写出一篇博文。要是什么时候自己也遗忘了一部分的知识，还可以回过头来看看以前写的文章，就如自己给自己写的参考书一样。&lt;/p&gt;

&lt;p&gt;也没有什么想写的了，既然题目都是短文，就让它短一点好了。&lt;/p&gt;

&lt;p&gt;最后感谢github提供的这个平台，真的是很良心，就连我的&lt;a href=&quot;http://www.baozijuan.com&quot;&gt;个人网站&lt;/a&gt;其实也是享受着github学生福利搭建起来的。也感谢我现在用的这个jekyll主题的&lt;a href=&quot;https://github.com/BlackrockDigital/startbootstrap-clean-blog-jekyll&quot;&gt;作者&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;祝新学期顺利。&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Feb 2017 00:00:00 +0000</pubDate>
        <link>https://congbao.github.io//2017/02/03/%E7%9F%AD%E6%96%87/</link>
        <guid isPermaLink="true">https://congbao.github.io//2017/02/03/%E7%9F%AD%E6%96%87/</guid>
        
        
      </item>
    
  </channel>
</rss>
